name: build-and-cache
on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  build-and-cache:
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 2 # Need to fetch at least 2 commits to compare

      - name: Setup Nu Tools
        uses: ck3mp3r/actions/nu-tools@main

      - name: Detect changed flakes and build to cache
        shell: nu {0}
        env:
          CACHIX_AUTH_TOKEN: ${{ secrets.CACHIX_AUTH_TOKEN }}
        run: |
          use nu-tools *

          print $"(ansi cyan_bold)ğŸ” Detecting flakes...(ansi reset)\n"

          # Dynamically discover all flake directories
          let all_flakes = (ls
            | where type == dir
            | where name !~ '^\.' # exclude hidden directories like .github
            | each {|dir|
                if ($"($dir.name)/flake.nix" | path exists) {
                  $dir.name
                }
              }
            | compact
          )

          print $"Found flakes in repository:"
          $all_flakes | each {|f| print $"  â€¢ ($f)"}
          print ""

          # Determine which flakes to build based on trigger
          let flakes_to_build = if $env.GITHUB_EVENT_NAME == "workflow_dispatch" {
            print $"(ansi blue)â„¹ Manual trigger detected - building ALL flakes(ansi reset)\n"
            $all_flakes
          } else {
            print $"(ansi blue)â„¹ Push trigger detected - building only CHANGED flakes(ansi reset)\n"

            # Get list of changed files in the last commit
            let changed_files = (git diff --name-only HEAD~1 HEAD | lines)

            print $"Changed files:"
            $changed_files | each {|f| print $"  â€¢ ($f)"}
            print ""

            # Extract flake directories from changed files
            ($changed_files
              | each {|file|
                  let parts = ($file | split row '/')
                  if ($parts | length) > 0 {
                    $parts.0
                  } else {
                    null
                  }
                }
              | uniq
              | where {|dir| $dir in $all_flakes}
              | uniq
            )
          }

          # Filter to only existing flake directories (handles deleted flakes)
          let existing_flakes = ($flakes_to_build
            | where {|flake| ($flake | path exists) and ($"($flake)/flake.nix" | path exists)}
          )

          # Filter to only flakes that have buildable packages
          print $"(ansi blue)Checking which flakes have buildable packages...(ansi reset)"
          let buildable_flakes = ($existing_flakes
            | each {|flake|
                try {
                  let has_packages = (nix flake show $"./($flake)" --json
                    | from json
                    | get --optional packages
                    | default {}
                    | values
                    | any {|sys| ($sys | columns | length) > 0}
                  )
                  if $has_packages { $flake } else { null }
                } catch {
                  null
                }
              }
            | compact
          )

          if ($buildable_flakes | is-empty) {
            print $"(ansi yellow)âš  No flakes with buildable packages found(ansi reset)"
            exit 0
          }

          print $"(ansi green)âœ“ Flakes to build:(ansi reset)"
          $buildable_flakes | each {|f| print $"  â€¢ ($f)"}
          print ""

          # Build and cache each flake
          for flake in $buildable_flakes {
            print $"(ansi cyan_bold)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”(ansi reset)"
            print $"(ansi cyan_bold)ğŸ“¦ Processing flake: ($flake)(ansi reset)"
            print $"(ansi cyan_bold)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”(ansi reset)\n"

            try {
              # Build flake from the flake directory
              cd $flake
              publish-to-cachix ck3mp3r --flake ".#"
              cd ..
            } catch {|err|
              print $"(ansi red_bold)âŒ Failed to build/cache ($flake):(ansi reset)"
              print $err
              print $"(ansi yellow)âš  Continuing with next flake...(ansi reset)\n"
              cd ..
            }

            print ""
          }

          print $"(ansi green_bold)âœ… Build and cache workflow completed!(ansi reset)"
